/* Automatically generated by p4c-ubpf from testdata/p4_16_samples/ubpf.p4 on Wed Sep 17 21:28:34 2025
 */
#ifndef _P4_GEN_HEADER_
#define _P4_GEN_HEADER_
#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>
#include "ubpf_common.h"


enum ubpf_action{
ABORT,
DROP,
PASS,
REDIRECT,
};

struct standard_metadata {
    uint32_t input_port; /* bit<32> */
    uint32_t packet_length; /* bit<32> */
    enum ubpf_action output_action; /* ubpf_action */
    uint32_t output_port; /* bit<32> */
    uint8_t clone; /* bool */
    uint32_t clone_port; /* bit<32> */
};

enum HashAlgorithm{
lookup3,
};

struct ethernet_h {
    uint64_t dstAddr; /* bit<48> */
    uint64_t srcAddr; /* bit<48> */
    uint16_t etherType; /* bit<16> */
    uint8_t ebpf_valid;
};

struct ipv4_h {
    uint8_t version; /* bit<4> */
    uint8_t ihl; /* bit<4> */
    uint8_t diffserv; /* bit<8> */
    uint16_t totalLen; /* bit<16> */
    uint16_t identification; /* bit<16> */
    uint8_t flags; /* bit<3> */
    uint16_t fragOffset; /* bit<13> */
    uint8_t ttl; /* bit<8> */
    uint8_t protocol; /* bit<8> */
    uint16_t hdrChecksum; /* bit<16> */
    uint32_t srcAddr; /* bit<32> */
    uint32_t dstAddr; /* bit<32> */
    uint8_t ebpf_valid;
};

struct snap_header_h {
    uint8_t dsap; /* bit<8> */
    uint8_t ssap; /* bit<8> */
    uint8_t control_; /* bit<8> */
    uint32_t oui; /* bit<24> */
    uint16_t type_; /* bit<16> */
    uint8_t ebpf_valid;
};

struct roce_header_h {
    uint8_t ib_grh[40]; /* bit<320> */
    uint8_t ib_bth[12]; /* bit<96> */
    uint8_t ebpf_valid;
};

struct roce_v2_header_h {
    uint8_t ib_bth[12]; /* bit<96> */
    uint8_t ebpf_valid;
};

struct fcoe_header_h {
    uint8_t version; /* bit<4> */
    uint8_t type_; /* bit<4> */
    uint8_t sof; /* bit<8> */
    uint32_t rsvd1; /* bit<32> */
    uint32_t ts_upper; /* bit<32> */
    uint32_t ts_lower; /* bit<32> */
    uint32_t size_; /* bit<32> */
    uint8_t eof; /* bit<8> */
    uint32_t rsvd2; /* bit<24> */
    uint8_t ebpf_valid;
};

struct vlan_tag_h {
    uint8_t pcp; /* bit<3> */
    uint8_t cfi; /* bit<1> */
    uint16_t vid; /* bit<12> */
    uint16_t etherType; /* bit<16> */
    uint8_t ebpf_valid;
};

struct vlan_tag_3b_h {
    uint8_t pcp; /* bit<3> */
    uint8_t cfi; /* bit<1> */
    uint8_t vid; /* bit<4> */
    uint16_t etherType; /* bit<16> */
    uint8_t ebpf_valid;
};

struct vlan_tag_5b_h {
    uint8_t pcp; /* bit<3> */
    uint8_t cfi; /* bit<1> */
    uint32_t vid; /* bit<20> */
    uint16_t etherType; /* bit<16> */
    uint8_t ebpf_valid;
};

struct ieee802_1ah_h {
    uint8_t pcp; /* bit<3> */
    uint8_t dei; /* bit<1> */
    uint8_t uca; /* bit<1> */
    uint8_t reserved; /* bit<3> */
    uint32_t i_sid; /* bit<24> */
    uint8_t ebpf_valid;
};

struct mpls_h {
    uint32_t label; /* bit<20> */
    uint8_t tc; /* bit<3> */
    uint8_t bos; /* bit<1> */
    uint8_t ttl; /* bit<8> */
    uint8_t ebpf_valid;
};

struct ipv6_h {
    uint8_t version; /* bit<4> */
    uint8_t trafficClass; /* bit<8> */
    uint32_t flowLabel; /* bit<20> */
    uint16_t payloadLen; /* bit<16> */
    uint8_t nextHdr; /* bit<8> */
    uint8_t hopLimit; /* bit<8> */
    uint8_t srcAddr[16]; /* bit<128> */
    uint8_t dstAddr[16]; /* bit<128> */
    uint8_t ebpf_valid;
};

struct icmp_h {
    uint8_t type_; /* bit<8> */
    uint8_t code; /* bit<8> */
    uint16_t hdrChecksum; /* bit<16> */
    uint8_t ebpf_valid;
};

struct icmpv6_h {
    uint8_t type_; /* bit<8> */
    uint8_t code; /* bit<8> */
    uint16_t hdrChecksum; /* bit<16> */
    uint8_t ebpf_valid;
};

struct tcp_h {
    uint16_t srcPort; /* bit<16> */
    uint16_t dstPort; /* bit<16> */
    uint32_t seqNo; /* bit<32> */
    uint32_t ackNo; /* bit<32> */
    uint8_t dataOffset; /* bit<4> */
    uint8_t res; /* bit<4> */
    uint8_t flags; /* bit<8> */
    uint16_t window; /* bit<16> */
    uint16_t checksum; /* bit<16> */
    uint16_t urgentPtr; /* bit<16> */
    uint8_t ebpf_valid;
};

struct udp_h {
    uint16_t srcPort; /* bit<16> */
    uint16_t dstPort; /* bit<16> */
    uint16_t length_; /* bit<16> */
    uint16_t checksum; /* bit<16> */
    uint8_t ebpf_valid;
};

struct sctp_h {
    uint16_t srcPort; /* bit<16> */
    uint16_t dstPort; /* bit<16> */
    uint32_t verifTag; /* bit<32> */
    uint32_t checksum; /* bit<32> */
    uint8_t ebpf_valid;
};

struct gre_h {
    uint8_t C; /* bit<1> */
    uint8_t R; /* bit<1> */
    uint8_t K; /* bit<1> */
    uint8_t S; /* bit<1> */
    uint8_t s; /* bit<1> */
    uint8_t recurse; /* bit<3> */
    uint8_t flags; /* bit<5> */
    uint8_t ver; /* bit<3> */
    uint16_t proto; /* bit<16> */
    uint8_t ebpf_valid;
};

struct nvgre_h {
    uint32_t tni; /* bit<24> */
    uint8_t reserved; /* bit<8> */
    uint8_t ebpf_valid;
};

struct erspan_header_v1_h {
    uint8_t version; /* bit<4> */
    uint16_t vlan; /* bit<12> */
    uint8_t priority; /* bit<6> */
    uint16_t span_id; /* bit<10> */
    uint8_t direction; /* bit<8> */
    uint8_t truncated; /* bit<8> */
    uint8_t ebpf_valid;
};

struct erspan_header_v2_h {
    uint8_t version; /* bit<4> */
    uint16_t vlan; /* bit<12> */
    uint8_t priority; /* bit<6> */
    uint16_t span_id; /* bit<10> */
    uint32_t unknown7; /* bit<32> */
    uint8_t ebpf_valid;
};

struct ipsec_esp_h {
    uint32_t spi; /* bit<32> */
    uint32_t seqNo; /* bit<32> */
    uint8_t ebpf_valid;
};

struct ipsec_ah_h {
    uint8_t nextHdr; /* bit<8> */
    uint8_t length_; /* bit<8> */
    uint16_t zero; /* bit<16> */
    uint32_t spi; /* bit<32> */
    uint32_t seqNo; /* bit<32> */
    uint8_t ebpf_valid;
};

struct arp_rarp_h {
    uint16_t hwType; /* bit<16> */
    uint16_t protoType; /* bit<16> */
    uint8_t hwAddrLen; /* bit<8> */
    uint8_t protoAddrLen; /* bit<8> */
    uint16_t opcode; /* bit<16> */
    uint8_t ebpf_valid;
};

struct arp_rarp_ipv4_h {
    uint64_t srcHwAddr; /* bit<48> */
    uint32_t srcProtoAddr; /* bit<32> */
    uint64_t dstHwAddr; /* bit<48> */
    uint32_t dstProtoAddr; /* bit<32> */
    uint8_t ebpf_valid;
};

struct eompls_h {
    uint8_t zero; /* bit<4> */
    uint16_t reserved; /* bit<12> */
    uint16_t seqNo; /* bit<16> */
    uint8_t ebpf_valid;
};

struct vxlan_h {
    uint8_t flags; /* bit<8> */
    uint32_t reserved; /* bit<24> */
    uint32_t vni; /* bit<24> */
    uint8_t reserved2; /* bit<8> */
    uint8_t ebpf_valid;
};

struct nsh_h {
    uint8_t oam; /* bit<1> */
    uint8_t context; /* bit<1> */
    uint8_t flags; /* bit<6> */
    uint8_t reserved; /* bit<8> */
    uint16_t protoType; /* bit<16> */
    uint32_t spath; /* bit<24> */
    uint8_t sindex; /* bit<8> */
    uint8_t ebpf_valid;
};

struct nsh_context_h {
    uint32_t network_platform; /* bit<32> */
    uint32_t network_shared; /* bit<32> */
    uint32_t service_platform; /* bit<32> */
    uint32_t service_shared; /* bit<32> */
    uint8_t ebpf_valid;
};

struct genv_h {
    uint8_t ver; /* bit<2> */
    uint8_t optLen; /* bit<6> */
    uint8_t oam; /* bit<1> */
    uint8_t critical; /* bit<1> */
    uint8_t reserved; /* bit<6> */
    uint16_t protoType; /* bit<16> */
    uint32_t vni; /* bit<24> */
    uint8_t reserved2; /* bit<8> */
    uint8_t ebpf_valid;
};

struct genv_opt_A_h {
    uint16_t optClass; /* bit<16> */
    uint8_t optType; /* bit<8> */
    uint8_t reserved; /* bit<3> */
    uint8_t optLen; /* bit<5> */
    uint32_t dt; /* bit<32> */
    uint8_t ebpf_valid;
};

struct genv_opt_B_h {
    uint16_t optClass; /* bit<16> */
    uint8_t optType; /* bit<8> */
    uint8_t reserved; /* bit<3> */
    uint8_t optLen; /* bit<5> */
    uint64_t dt; /* bit<64> */
    uint8_t ebpf_valid;
};

struct genv_opt_C_h {
    uint16_t optClass; /* bit<16> */
    uint8_t optType; /* bit<8> */
    uint8_t reserved; /* bit<3> */
    uint8_t optLen; /* bit<5> */
    uint32_t dt; /* bit<32> */
    uint8_t ebpf_valid;
};

struct Headers_t {
    struct ethernet_h ethernet; /* ethernet_h */
    struct ipv4_h ipv4; /* ipv4_h */
    struct tcp_h tcp; /* tcp_h */
};

struct metadata {
};


enum ubpf_map_type {
    UBPF_MAP_TYPE_ARRAY = 1,
    UBPF_MAP_TYPE_HASHMAP = 4,
    UBPF_MAP_TYPE_LPM_TRIE = 5,
};
struct ubpf_map_def {
    enum ubpf_map_type type;
    unsigned int key_size;
    unsigned int value_size;
    unsigned int max_entries;
    unsigned int nb_hash_functions;
};

#if CONTROL_PLANE
static void init_tables() 
{
    uint32_t ebpf_zero = 0;
}
#endif
#endif
